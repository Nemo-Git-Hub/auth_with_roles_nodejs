// -= authController.js =-

// здесь описываем все функции по взаимодействию с пользователем: регистрацию, авторизацию и получение пользователей

const User = require('./models/User') // импортируем модель юзера
const Role = require('./models/Role') // импортируем модель ролей
const bcrypt = require('bcryptjs') // импортируем bcryptjs для хеширования паролей
const jwt = require('jsonwebtoken') // импортируем jsonwebtoken для работы с токенами
const { validationResult } = require('express-validator') // Экспортируем фун validationResult из express-validator.
// Она будет возвращать ошибки, кот были получены вследствие экспресс-валидации перед началом выполнения фун мы эти ошибки будем получать
const {secret} = require("./config") // используя деструктуризацию, импортируем config и получаем не весь объект config, а только секретный ключ

const generateAccessToken = (id, roles) => { // Создали стрелочную фун, кот параметрами принимает id юзера и его roles.
	// Это необходимо, чтобы мы могли спрятать в него эту информацию. Она называется payload
  const payload = { // Создадим отдельно объект и в него помещаем id и roles. Сюда также можем прятать вообще любую информацию: имя пользователя и вообще все что угодно
		id,
	  roles
  } // По итогу фун должна вернуть нам токен. Для этого
	return jwt.sign(payload, secret, {expiresIn: "24h"}) // У модуля jwt вызываем фун sign. Параметрами передаем
	// 1-payload, 2-секретный ключ secret из файла конфигурации config (по нему будет расшифровываться токен), 3-объект опций. Здесь укажем то, сколько будет жить токен {expiresIn: "24h"}
 }

class authController { // Создаем класс, внутри кот объявляем несколько фун. Они все принимают 2 парам (запрос, ответ)
	// Из запроса req будем получать информацию, кот присылает юзер, а с помощью ответа res будем ему что-то отправлять
	// Все фун try-catch
	async registration(req, res) { // регистрация
		try { // перед началом выполнения фун получаем ошибки, кот были получены вследствие экспресс-валидации
			const errors = validationResult(req) // вызываем фун и параметром в нее передаем (реквест-запрос), фун вызовет необходимые поля и провалидирует их
			if (!errors.isEmpty()) { // проверим, если массив этих ошибок не пустой, то нам необходимо
				return res.status(400).json({message: "Ошибка при регистрации", errors}) // вернуть на клиент ошибку, так же
				// дополнительно передаем эту ошибку({, errors}) чтобы можно было обработать (но это другая история))))
			}
			const {username, password} = req.body // извлекаем имя и пароль из тела запроса
			const candidate = await User.findOne({username}) // проверяем есть ли пользователь с таким именем у нас в базе
			if (candidate) { // если есть - возвращаем ошибку, что такой уже есть
				return res.status(400).json({message: "Пользователь с таким именем уже существует"})
			} // если такого юзера нет, то
			const hashPassword = bcrypt.hashSync(password, 7) // хешируем пароль
			const userRole = await Role.findOne({value: "USER"}) // Получаем из БД роль пользователя. Сделаем его юзером
			const user = new User({username, password: hashPassword, roles: [userRole.value]}) // Создаем юзера, передаем
			// в объект username, захешированный пароль, в массив ролей добавляем поле value с полученной ролью. Т.е выше мы
			// получили объект и из него нам нужно выцепить value
			await user.save() // сохраняем пользователя в БД
			return res.json({message: "Пользователь успешно зарегистрирован"}) // возвращаем на клиент сообщение об успешной регистрации
		} catch (e) {
			console.log(e) // выводим в консоль сообщение об ошибке
			res.status(400).json({message: 'Registration error'}) // оповещаем наш клиент о том, что произошла ошибка
			// (указываем статус ошибки и передаем сообщение в json
		}
	}
	
	async login(req, res) { // логин
		try {
		const {username, password} = req.body // из тела запроса вытаскиваем имя и пароль
			const user = await User.findOne({username}) // ищем пользователя с таким именем в БД
			if (!user) { // Проверяем: если пользователь не был найден, т.е. объект пустой, то
				return res.status(400).json({message: `Пользователь ${username} не найден`}) // возвращаем на клиент ошибку и сообщение
			} // если пользователь найден, то необходимо сравнить пароль в БД с введенным паролем (из тела завпроса)
			const validPassword = bcrypt.compareSync(password, user.password) // Создаем переменную, в которой будет храниться
			// логическое значение того валиден пароль или нет. Для того чтобы сравнить захешированный пароль и обычный
			// используется фун compareSync (она также есть в доках bcrypt). В параметрах первым передаем обычный пароль, а
			// вторым захешированный. Захешированный пароль получаем из того пользователя, которого мы получили в БД.
			if (!validPassword) { // проверяем, если пароль НЕ валидный
				return res.status(400).json({message: `Введен неверный пароль`}) // возвращаем статус 400 и сообщение
			} // Если валиден, то генерируем токен с помощью 'jsonwebtoken'
			const token = generateAccessToken(user._id, user.roles) // Создали переменную, в которую будем возвращать фун,
			// кот сейчас сами и создадим за пределами класса (см. l.11) и параметрами перелаем в нее id и roles user.
			// Внимание: Перед id есть _, кот генерирует МонгоДБ, чтобы показать, что это поле не может изменяться
			return res.json({token}) // остается этот токен вернуть ответом на клиент
		} catch (e) {
			console.log(e) // выводим в консоль сообщение об ошибке
			res.status(400).json({message: 'Login error'}) // оповещаем наш клиент о том, что произошла ошибка
			// (указываем статус ошибки и передаем сообщение в json
		}
	}
	
	async getUsers(req, res) { // получение пользователей
		try {
			const users = await User.find() // Делаем запрос к БД (через await), вызываем фун find и в нее ничего не передаем параметром
			// фрагмент кода удален после создания и сохранения в БД админа и юзера
			// const userRole = new Role() // создаем роль юзера
			// const adminRole = new Role({value: "ADMIN"}) // создаем роль админа, указываем значение админ (юзер по умолч)
			// await userRole.save() // вызываем фун save, для сохранения ролей в БД
			// await adminRole.save()
			// res.json('server is working') // вызываем фун json, которая будет возвращать обратно на клиент какое-то
			// сообщение отправляем в Postman запрос localhost:5000/auth/users и затем проверяем в БД наличие ролей.
			// После этого данный фрагмент кода можно удалить. Другого кода в блоке try не было.
			res.json(users) // Возвращаем от сервера массив этих пользователей
		} catch (e) {
		
		}
	}
}

module.exports = new authController() // экспортируем объект данного класса.
// Теперь вернемся в роутер и импортируем там этот контроллер

// -= authController.js =-